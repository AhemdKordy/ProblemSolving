#include <bits/stdc++.h>
#include <stdio.h>
#include <cstdio>
#include <fstream>
#define ll long long
#define ld long double
#define endl "\n"
#define ull unsigned long long
#define ALL(v) ((v).begin()), ((v).end())
#define INCR(v) sort(ALL(v))
#define DECR(v) SORTI(v), reverse(ALL(v))
#define SZ(v)   ((int)((v).size()))
#define LP(c,x,n)  for(int c=x;c<n;c++)
#define LO(c,n,x)  for(int c=n;c>=x;c--)
#define watch(x) cout << (#x) << " is " << (x) << endl
#define PB push_back
#define F first
#define S second
#define PI ( 2 * acos(0.0))
#define EPS 1e-8
#define INF 1.0/0.0
#define Yala_Besor3a ios_base::sync_with_stdio(0),ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)
#define ReadFile freopen("input.txt","r",stdin)
#define WriteFile freopen("output.txt","w",stdout)
using namespace std;
/*
///////////////////////////////////////////////
this code is by Ahmed ....

**      *            **    *    **    *      *
**   **      *       **  *      **     **   **
**  **     *   *     ***        **       *****
** **    *       *   **         **          **
***     *         *  **         **          **
** **    *       *   **     *****           **
**  **     *   *     **    *    **   *      **
**   **      *       **    *    **   **   **
**      *            **     ****       ***

///////////////////////////////////////////////
*/
// sum from 1 to n = (n*(n+1))/2
// sum of even numbers from 1 to n =  total_even_numbers*(total_even_numbers+1)
//sum from first to last = total_numbers * ( first / 2 + last / 2 )
//A=65 // a=97  // num=48
//decimal to binary :: while(n!=0) {r=(n%2==0 ?"0":"1")+r; n/=2;}
//int value = atoi(myString.c_str());
//Hot Mod (a%n+n)%n

const int OO = 0x3f3f3f3f,NegOO= -1*OO,N =35,mod = 1e9+7 ;
ll Pow(ll base,ll exponent)
{
    ll result = 1;
    while (exponent > 0)
    {
        if (exponent % 2 == 1)
            result = (result * base) % mod;
        exponent = exponent >> 1;
        base = (base * base) % mod;
    }
    return result;
}

ll PowOf2(int k)
{
    ll ans=1;
    while(k--)
    {
        ans<<=1;
    }
    return ans;
}
int GetLowestBitPos(int value)
{
   int pos = 0;
   while (!(value & 1))
   {
      value >>= 1;
      ++pos;
   }
   return ++pos;
}


ld dis(int x1,int y1,int x2,int y2)
{
    return sqrt(pow(x2-x1,2)+pow(y2-y1,2));
}
bool checklucky(int n)
{
    while(n)
    {
        if(n%10!=4&&n%10!=7)return false;
        n/=10;
    }
    return true;
}
int logg2(ll n)
{
    int ans=0;
    while(n)ans++,n/=2;
    return --ans;
}
vector<ll>divisors;
void numdiv(ll n)
{
    ll ans=0;
    for(ll c=1;c*c<=n; c++)
    {
        if(n%c==0)divisors.push_back(c);
        if(n/c!=c&&n%(n/c)==0)divisors.push_back(n/c);
    }
}
bool prime[maxarr];
void Sieve() {
    memset(prime, 1, sizeof(prime));
    prime[0] = prime[1] = 0;
    for (int c = 2; c * c <= maxarr; c++) {
        if (prime[c]) {
            for (int i = 2 * c; i < maxarr; i += c)prime[i] = 0;
        }
    }
}
vector<ll>primes;
void primeFactors(ll n)
{
    while (n%2 == 0)
    {
        primes.push_back(2);
        n = n/2;
    }

    for (ll i = 3; i *i<= n; i = i+2)
    {

        while (n%i == 0)
        {
            primes.push_back(i);
            n = n/i;
        }
    }

    if (n > 2)
        primes.push_back(n);
}
///////////////////////////////////////////////////////////////////////////////////////
//  NcR using DP
ll dp[35][35];
ll NchooseR(int n, int r)
{
  if (r==0 || r==n) return 1;
  ll &rf=dp[n][r];
  if(~rf)return rf;
  return  rf=NchooseR(n-1, r-1) + NchooseR(n-1, r);
}
//  NcR using recursion
ll choosing(int n,int r)
{
	if(n==r||r==0)return 1;
	if(r==1)return n;
	return n*choosing(n-1,r-1)/r;
}
// NcR using Loops
ll NcR(int n,int r){
   if(r>n/2)r=n-r;
   ll res=1;
    for(int i=0;i<r;i++){
        res=res*(n-i)/(i+1);
    }
    return res;
}
ll gcd (ll x,ll y)
{if(y==0)return x;return gcd(y,x%y);}

ll lcm(ll a,ll b)
{return a/gcd(a,b) * b;}

ull todecimal(string x)
{
    ull ans=0;
    reverse(x.begin(),x.end());
    forr(c,0,x.length())
    {
        if(x[c]=='1')
            ans+=pow(2,c);
    }
    return ans;
}
string tobinary(ll x)
{
    string ans;
    while(x)
    {
        ans+=(char)(x%2+'0');
        x/=2;
    }
    reverse(ans.begin(),ans.end());
    return ans;
}

int StringToInt(string score)
{
	int ans = 0;
	int sz = score.size();
	reverse(score.begin(), score.end());
	for (int c = 0; c < sz; c++)
	{
		ans += (score[c] - '0')*powl(10, c);
	}
	return ans;
}

bool palindrome(string x)
{
    LP(c,0,SZ(x)/2)
    {
        if(x[c]!=x[SZ(x)-c-1])return 0;
    }
    return 1;
}

//////////////////////////////////////////////////////////////////////////////////////

double Distance(int x1,int y1,int x2,int y2)
{
	double d1=(x2-x1)*(x2-x1),d2=(y2-y1)*(y2-y1);
	return sqrt(d1+d2);
}

double toDegreeFromMinutes(double mins)
{
return (mins/60);
}

double ToRadian(double degree)
{
return (degree*PI/180.0);
}

double toDegree(double radian)
{
if(radian<0)radian+=2*PI;
return (radian*180/PI);
}
double disToLine(double a, double b,double c, double x, double y)
{
    double fo2=a*x+b*y+c;
    fo2=abs(fo2);
    double t7t=sqrtl(a*a+b*b);
    return fo2/t7t;
}
pair<pair<int,int>,int> Get_Eqn_from_2Points(int x1,int y1,int x2,int y2)
{
int a=y1-y2;
int b = x2-x1;
int c=(x1-x2)*y1 + (y2-y1)*x1;
return make_pair(make_pair(a,b),c);
}

double fixAngle(double A)
{
return A>1?1:(A<-1?-1:A);
}
// A : angle ,, a 
// sin (A)/a =sin(B)/b =sin(C)/c
double getSide_a_bAB(double b,double A,double B)
{
return (sin(A)*b)/sin(B);
}

double getAngle_A_abB(double a,double b,double B)
{
return asin(fixAngle( (a*sin(b))/b) );
}


// a^2 =b^2+c^2-2*b*c*cos(A)
double getAngle_A_abc(double a,double b,double c)
{
return acos(fixAngle(  (b*b+c*c-a*a)/(2*b*c) ) );
} 

int CompareDouble(double a,double b)
{
return fabs(a-b)<=EPS ? 0: a<b ? -1 : 1 ;
}
///////////////////////////////////////////////////////////////////////////////////
// DSU UninFind

struct DSU
{
	vector<int>parent,Gsize;
	int Forests,NumNodes;
	DSU(int n)
	{
		parent.resize(n+5);
		Gsize.resize(n+5);
		Forests=n;
		NumNodes=n;
		LP(c,0,n)parent[c]=c,Gsize[c]=1;
	}
	int findParent(int x)
	{
		if(parent[x]==x)return x;
		return parent[x]=findParent(parent[x]);
	}
	int GroupSize(int x)
	{
		return Gsize[findParent(x)];
	}
	void link(int x,int y)
	{
		x=findParent(x),y=findParent(y);
		if(x==y)return;
		if(Gsize[x]>=Gsize[y])Gsize[x]+=Gsize[y],parent[y]=x;
		else
		{
			Gsize[y]+=Gsize[x],parent[x]=y;
		}
		Forests--;
	}

	bool IsSameGroup(int x,int y)
	{
		return findParent(x)==findParent(y);
	}
	vector<vector<int> > ConectedComponents()
	{
		vector<vector<int>>List;
		List.resize(NumNodes+5);
		for(int c=0;c<=NumNodes;c++)
		{
			List[findParent(c)].push_back(c);
		}
		return List;
	}
};


/////////////////////////// MST_Kruskal

struct edge {
	int from,to,cost;
};
pair<int,vector<edge> > MST_Kruskal(vector<edge> edgeList,int n) // o (E log V)
{
	DSU uf(n);
	vector<edge>edges;
	int MST_Cost=0;
	priority_queue<edge>q;// edges are multiplied by -1 to be sorted Incr
	for(auto u:edgeList)q.push(u);
	while(!q.empty()){
		edge e = q.top();q.pop();
		if(uf.IsSameGroup(e.from,e.to) ){
			MST_Cost+=e.cost;
			uf.link(e.from,e.to);
			edges.push_back(e);		
		}
	}
	if(SZ(edges)!=n-1) return {NegOO,vector<edge>() );
	else return {MST_Cost,edges};
}


///////////////////////////



///////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////
//  KMP string matching
vector<int>computePrefix_LSP_(string pat)
{
    int m=pat.size();
    vector<int>longPref(m);
    for (int i = 1,k = 0; i < m; ++i) {
        while(k>0&&pat[k]!=pat[i])
            k=longPref[k-1];

        if(pat[k]==pat[i])
            longPref[i]=++k;
        else
            longPref[i]=k;
    }
    return longPref;
}
vector<int> KMP(string str,string pat)
{
    int n=str.size();
    int m=pat.size();
    vector<int>longPref=computePrefix_LSP_(pat);
    vector<int>ans;
    for(int i=0,k=0;i<n;++i)
    {
        while(k>0&&str[i]!=pat[k])
            k=longPref[k-1];

        if(pat[k]=str[i])++k;

        if(k==m)
        {
            ans.push_back(i-m+1);
            k=longPref[k-1];
        }
    }
    return ans;
}

///////////////////////////////////////////////////////////////////////////////////
///////// Compression
vector<int> compress(vector<int>inp)
{
    vector<int>tmp,ans;
    int n=inp.size();
    for (int i = 0; i < n; ++i)
    {
        tmp.push_back(inp[i]);
    }
    sort(tmp.begin(),tmp.end());
    tmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());
    for (int i = 0; i < n; ++i)
    {
        ans.push_back(lower_bound(tmp.begin(),tmp.end(),inp[i])-tmp.begin());
    }
    return ans;
}
///////////////////////////////////////////////////////////////////////////////////
///////// ford fulkerson' Max Flow
int path[N],int costs[N][N],pathLen;
int getPath(int curNode,int dest,int curLen,int minFlow) {
    path[curLen] = curNode;
    if (curNode == dest) {
        pathLen = curLen + 1;
        return minFlow;
    }
    int ans = 0;
    vis[curNode] = 1;
    LP(c, 1, n+1) {
        if(vis[c]||costs[curNode][c]<=0)continue;
        ans=getPath(c,dest,curLen+1,min(costs[curNode][c],minFlow));
        if(ans>0)break;
    }
    return ans;
}
int maxFlow(int src,int dest) { 
    int totalFlow = 0, curFlow;
    while (true) {
        memset(vis, 0, sizeof(vis));
        curFlow = getPath(src, dest, 0, OO);
        if (curFlow <= 0)break;
        LP(c, 1, pathLen) {
            costs[path[c - 1]][path[c]] -= curFlow;
            costs[path[c]][path[c - 1]] += curFlow;
        }
        totalFlow+=curFlow;
    }
    return totalFlow;
}
///////////////////////////////////////////////////////////////////////////////////
//// TSP DP
bool vis [CITY] [1 << CITY]; // is_visited
int val [CITY] [1 << CITY]; // cost at particular state
int weight [CITY] [CITY]; // given weight
 
int dp (int at, int mask)
{
    if ( mask ==  (1 << CITY) - 1 ) { // all visited
        vis [at] [mask] = true;
        return val [at] [mask];
    }
 
    if ( vis [at] [mask] ) return val [at] [mask];
    vis [at] [mask] = true;
 
    int ans = inf;
    int cost;
 
    for ( int i = 0; i < CITY; i++ ) {
        if ( weight [at] [i] != -1 && (mask & (1 << i)) == 0 ) {
            cost = dp (i, mask | (1 << i)) + weight [at] [i];
            if ( ans > cost ) ans = cost;
        }
    }
 
    return val [at] [mask] = ans;
}

//////////////////////////////////////////////////////////////////////////////////

////////////////// sorting a vector of structs 

bool compare(const data &a, const data &b)
{
    return a.word.size() < b.word.size(); // Increasing by word size
} 

//////////////////


//int dx[] = {0, 0, -1, 1, -1, -1, 1, 1};/*l,r,u,d,ur,ul,dl,dr */
//int dy[] = {-1, 1, 0, 0, 1, -1, -1, 1};

//int dx[]= {-1, 1, 0, 0};/*u,d,r,l*/
//int dy[]= {0, 0, 1, -1};
const int OO = 0x3f3f3f3f,NegOO= -1*OO,N =5e3+5,mod = 1e9+7 ;
